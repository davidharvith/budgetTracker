Personal Technical File
1. Backend Architecture and Class Relationships
Layered Architecture
Controller Layer:
Controllers are the entry point for HTTP requests. Each controller defines REST API endpoints for a specific domain (e.g., BudgetController for budgets, TransactionController for transactions).

Role: Validate incoming data (often as DTOs), extract authentication info, and delegate business logic to the service layer.

Relationship: Controllers depend on services and DTOs.

Service Layer:
Services encapsulate business logic and orchestrate operations using repositories.

Role: Implement core application logic, enforce business rules, and coordinate data access and updates.

Relationship: Services depend on repositories for data access and may use DTOs for communication with controllers.

Repository Layer:
Repositories abstract the database using Spring Data JPA.

Role: Provide CRUD operations for entities (e.g., BudgetRepository, UserRepository).

Relationship: Repositories operate on model entities and are used by services.

Model Layer (Entities):
Entities represent domain objects and are mapped to database tables.

Role: Define the structure of application data (e.g., User, Budget, Transaction).

Relationship: Used by repositories for persistence and by services for business logic.

DTOs (Data Transfer Objects):
DTOs are used to transfer data between the client and server, decoupling the API contract from internal models.

Request DTOs: Used by controllers to receive input (TransactionRequest, BudgetRequest).

Response DTOs: Used to send structured data back to the client (CategorySummary, BudgetSummaryResponse).

Relationship: DTOs are used by controllers (for input/output) and sometimes by services for internal logic.

Security Layer:

SecurityConfig: Configures JWT authentication, endpoint protection, CORS, and password encoding.

JwtAuthFilter: Intercepts requests, validates JWTs, and sets authentication in the security context.

CustomUserDetailsService: Loads user details for authentication.

Relationship: Secures all endpoints, ensures only authenticated/authorized users access resources.

Exception Handling:

GlobalExceptionHandler: Catches and formats exceptions for consistent API error responses.

Custom exceptions like DuplicateResourceException.

Relationship: Ensures uniform error responses for all controllers.

Configuration:

AppConfig, OpenApiConfig: Application and Swagger/OpenAPI configuration.

Relationship: Sets up beans and documentation for the application.

Example Data Flow: Creating a Budget
Frontend sends a POST request to /api/budgets with a BudgetRequest DTO and JWT token.

BudgetController receives the request, validates the DTO, and extracts the authenticated user.

BudgetService is called by the controller, which:

Validates business rules.

Calls BudgetRepository to persist the new budget.

BudgetRepository saves the Budget entity in the database.

BudgetService returns the created entity or DTO.

BudgetController returns the response to the frontend.

2. Frontend Architecture and Data Flow
Structure
API Service (api.js):
Centralizes all API calls, attaches JWT token to requests, and handles base URL configuration.

Custom Hooks:

useBudgets: Fetches budgets, manages selection, handles loading/errors, and redirects if unauthenticated.

useSummary: Fetches and manages summary data for selected budget.

Components:

Register: Handles user registration, form validation, error display, and navigation.

Dashboard: Main UI for managing budgets, transactions, analytics, and summary cards.

BudgetControls, SummaryCards, ChartsSection, TransactionsSection: Modular UI components for specific dashboard features.

Example Data Flow: Adding a Transaction
User fills transaction form in the dashboard.

handleAddTransaction calls addTransaction from useTransactions hook.

Axios sends POST to /api/budgets/{id}/transactions with JWT.

Backend validates and saves transaction, returns updated data.

Frontend updates UI and analytics in real time.

3. Purpose of Key Classes and Files
Backend
Controllers:
Define API endpoints, validate input via DTOs, and delegate to services.

Services:
Contain business logic, enforce rules, and coordinate between controllers and repositories.

Repositories:
Interface with the database using JPA, abstracting SQL and persistence details.

DTOs:
Provide clear, versioned contracts for API requests and responses, decoupling internal models from external data.

Entities:
Represent domain objects and database tables.

Security Classes:
Handle authentication, authorization, and secure password storage.

Exception Handlers:
Ensure consistent error messaging and status codes across the API.

Frontend
API Service:
Handles all HTTP communication, JWT management, and error handling.

Custom Hooks:
Encapsulate data-fetching and state logic for budgets, summaries, and transactions.

Components:
Present UI for registration, dashboard, analytics, and transaction management.

4. Security and Configuration
JWT Authentication:
All protected endpoints require a valid JWT. Tokens are issued on login and stored in frontend localStorage.

Password Hashing:
User passwords are hashed with BCrypt before storage.

CORS:
Configured to allow requests from the frontend origin.

Secrets Management:
All secrets (DB credentials, JWT secret) are stored in .env files, not committed to Git, and injected as environment variables at runtime.

5. Key Design Decisions
Layered architecture for maintainability and testability.

DTOs to decouple API contracts from internal models.

JWT for stateless, scalable authentication.

Docker Compose for easy setup and consistent environments.

Nginx for SPA routing and static asset serving.

Centralized error handling and validation for robust APIs.